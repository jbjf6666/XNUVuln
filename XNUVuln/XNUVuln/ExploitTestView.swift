//
//  ExploitTestView.swift
//  XNUVuln
//
//  Created by 이지안 on 5/9/25.
//

import SwiftUI

struct AlertItem: Identifiable {
    let id = UUID()
    var title: Text
    var message: Text?
    var primaryButton: Alert.Button
    var secondaryButton: Alert.Button?
}

struct ExploitTestView: View {
    @StateObject var viewModel = FileManagerViewModel()
    @State private var offsetInput: String = "0"
    @State private var alertItem: AlertItem?

    private func getFileName(fromPath path: String?) -> String {
        guard let p = path, !p.isEmpty else { return "N/A" }
        return (p as NSString).lastPathComponent
    }

    var currentTargetFilePathForOperations: String {
        if let selected = viewModel.selectedFilePath, !selected.isEmpty {
            return selected
        }
        if let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {
            return documentsPath.appendingPathComponent("exploit_test_file.txt").path
        }
        return "/default_exploit_target.txt"
    }


    var body: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 10) {
                
                Text("File Browser (\(viewModel.itemsInCurrentPath.count) items)")
                    .font(.headline)
                FileBrowserView(viewModel: viewModel, selectedFileForExploitBinding: $viewModel.selectedFilePath)
                    .frame(height: 250)
                    .border(Color.gray, width: 0.5)
                    .padding(.bottom, 5)

                Text("Exploit Controls (Target: \(getFileName(fromPath: viewModel.selectedFilePath)))")
                    .font(.headline)
                
                Group {
                    Text("Offset (for single page zeroing):")
                        .font(.caption)
                    TextField("Enter offset (bytes)", text: $offsetInput)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .keyboardType(.numberPad)
                        .font(.caption)
                }
                
                HStack {
                    Spacer()
                    Button("Zero Out Single Page") {
                        let targetPath = currentTargetFilePathForOperations
                        guard !targetPath.isEmpty, targetPath != "/default_exploit_target.txt" else {
                            viewModel.operationStatus = "Error: No valid target file selected."
                            return
                        }
                        guard let offset = off_t(offsetInput) else {
                            viewModel.operationStatus = "Error: Invalid offset."
                            return
                        }
                        if offset < 0 {
                             viewModel.operationStatus = "Error: Offset cannot be negative."
                             return
                        }
                        let fileNameForAlert = getFileName(fromPath: targetPath)
                        self.alertItem = AlertItem(
                            title: Text("Confirm Zero Out Page"),
                            message: Text("Zero out ~16KB page at offset \(offset) in '\(fileNameForAlert)'? This is destructive."),
                            primaryButton: .destructive(Text("Confirm")) {
                                viewModel.attemptToZeroOutFilePage(filePath: targetPath, offset: offset)
                            },
                            secondaryButton: .cancel()
                        )
                    }
                    .buttonStyle(.bordered)
                    Spacer()
                    Button("Zero Out Entire File") {
                        let targetPath = currentTargetFilePathForOperations
                        guard !targetPath.isEmpty, targetPath != "/default_exploit_target.txt" else {
                            viewModel.operationStatus = "Error: No valid target file selected."
                            return
                        }
                        let fileNameForAlert = getFileName(fromPath: targetPath)
                        self.alertItem = AlertItem(
                            title: Text("Confirm Zero Out Entire File"),
                            message: Text("Zero out ALL pages of '\(fileNameForAlert)'? This is very destructive."),
                            primaryButton: .destructive(Text("Confirm")) {
                                viewModel.attemptToZeroOutEntireFile(filePath: targetPath)
                            },
                            secondaryButton: .cancel()
                        )
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(.red)
                    Spacer()
                }
                .padding(.vertical, 5)
                
                Divider()

                Group {
                    Text("Utility (for current target: \(getFileName(fromPath: viewModel.selectedFilePath))):")
                        .font(.caption)
                    HStack {
                        Button("Create/Overwrite Target") {
                            let targetPath = currentTargetFilePathForOperations
                            guard !targetPath.isEmpty, targetPath != "/default_exploit_target.txt" else {
                                viewModel.operationStatus = "Error: No valid target file selected to create/overwrite."
                                return
                            }
                            createTestFile(atPath: targetPath)
                        }
                        .buttonStyle(.bordered)
                        Spacer()
                        Button("Verify Target") {
                            let targetPath = currentTargetFilePathForOperations // Use the computed property
                             guard !targetPath.isEmpty, targetPath != "/default_exploit_target.txt" else {
                                viewModel.operationStatus = "Error: No valid target file selected to verify."
                                return
                            }
                            verifyTestFile(atPath: targetPath)
                        }
                        .buttonStyle(.bordered)
                    }
                }
                .padding(.top, 5)

                Divider()
                
                Text("Status:")
                    .font(.caption.weight(.bold))
                ScrollView {
                    Text(viewModel.operationStatus)
                        .font(.caption)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .textSelection(.enabled)
                }
                .frame(minHeight: 60, maxHeight: 100)
                .border(Color.gray, width: 0.5)

            }
            .padding()
            .navigationTitle("XNU Exploit Tool")
            .onAppear {
                if viewModel.selectedFilePath == nil || viewModel.selectedFilePath!.isEmpty {
                     if let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first {
                        viewModel.selectedFilePath = documentsPath.appendingPathComponent("exploit_test_file.txt").path
                    }
                }
            }
            .alert(item: $alertItem) { alertItem in
                if let secondaryButton = alertItem.secondaryButton {
                    return Alert(title: alertItem.title, message: alertItem.message, primaryButton: alertItem.primaryButton, secondaryButton: secondaryButton)
                } else {
                    return Alert(title: alertItem.title, message: alertItem.message, dismissButton: alertItem.primaryButton)
                }
            }
        }
    }
    
    func createTestFile(atPath path: String) {
        let fileName = getFileName(fromPath: path)
        let content = String(repeating: "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz\n", count: 512)
        do {
            try content.write(toFile: path, atomically: true, encoding: .utf8)
            viewModel.operationStatus = "Test file created/overwritten: \(fileName)."
        } catch {
            viewModel.operationStatus = "Failed to create test file \(fileName): \(error.localizedDescription)"
        }

        if (path as NSString).deletingLastPathComponent == viewModel.currentPath {
            viewModel.listDirectoryContents(atPath: viewModel.currentPath)
        }
    }
    
    func verifyTestFile(atPath path: String) {
        let fileName = getFileName(fromPath: path)
        viewModel.operationStatus = "Verifying \(fileName)..."
        DispatchQueue.global(qos: .background).async {
            var statusMessage = ""
            do {
                guard FileManager.default.fileExists(atPath: path) else {
                    statusMessage = "File does not exist: \(fileName)."
                    DispatchQueue.main.async { viewModel.operationStatus = statusMessage }
                    return
                }
                
                let fileHandle = try FileHandle(forReadingFrom: URL(fileURLWithPath: path))
                defer { fileHandle.closeFile() }
                let data = fileHandle.readData(ofLength: 200)
                
                if data.isEmpty {
                    let attributes = try? FileManager.default.attributesOfItem(atPath: path)
                    let fileSize = attributes?[.size] as? NSNumber ?? 0
                    if fileSize.int64Value == 0 {
                        statusMessage = "\(fileName) is empty (0 bytes)."
                    } else {
                        statusMessage = "\(fileName) appears empty but has size \(fileSize.int64Value). Read 0 bytes (first 200)."
                    }
                } else {
                    let allZeros = data.allSatisfy { $0 == 0 }
                    if allZeros {
                        statusMessage = "\(fileName) (first \(data.count) bytes) ARE ALL ZEROS. \nHex: \(data.map { String(format: "%02hhx", $0) }.joined().prefix(60))..."
                    } else {
                        if let content = String(data: data, encoding: .utf8) {
                            statusMessage = "\(fileName) (first \(data.count) bytes) are NOT all zeros. \nContent: \"\(content.prefix(60).replacingOccurrences(of: "\n", with: "\\n"))\"..."
                        } else {
                            statusMessage = "\(fileName) (first \(data.count) bytes) are NOT all zeros and not valid UTF-8. \nHex: \(data.map { String(format: "%02hhx", $0) }.joined().prefix(60))..."
                        }
                    }
                }
            } catch {
                statusMessage = "Failed to read/verify \(fileName): \(error.localizedDescription)"
            }
            DispatchQueue.main.async {
                viewModel.operationStatus = statusMessage
            }
        }
    }
}
